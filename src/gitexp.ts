/* standard lib */
import fs from 'fs'
import path from 'path'
import util from 'util'

/* core features */
import _ from 'lodash'
import Git from 'simple-git'
import archiver from 'archiver'
import fastFolderSize from 'fast-folder-size'
import { Octokit } from '@octokit/rest'
import { OptionValues } from 'commander'

/* aesthetic stuff */
import chalk from 'chalk'
import clear from 'clear'
import plural from 'pluralize'
import cliSpinner from 'cli-spinners'

import figlets from './figlets'
import spinnyBuilder from './spinner'
import { parseCommandLineArgs } from './cli'
import { censor, fmt, fmtBytes, getElapsedTimeFormatted, tabulateOccurrences } from './format'
import { str, len, isDef, uniq, largestWord } from './primitive'

import { IS_RUNNING_ON_CI_ENV } from './consts'

import {
  CloneStatus,
  ICloneFilters,
  IGitCloneSpinner,
  IGitHubAuthData,
  IGitHubStats,
  IOccurence,
  IRepository,
  IUserRepositories,
  IWorkingTimer,
  RepoOwnerType,
  RepoVisibility,
  SpinnyBuilder
} from './types'

/* -------------------------------------------------------------------------
                              HELPERS & UTILITIES
   ------------------------------------------------------------------------- */

const ffs = util.promisify(fastFolderSize)
const { log } = console

const errMsg = (e: any): string => (e instanceof Error ? e.message : typeof e === 'string' ? e : JSON.stringify(e))

const panic = (m: any): void => {
  console.error(errMsg(m))
  process.exit(1)
}

const DEST_DIR = path.join(__dirname, 'gitexp-out')

/* -------------------------------------------------------------------------
                                  CLI SPINNERS
   ------------------------------------------------------------------------- */

const updateCloneSpinner = (g: IGitCloneSpinner, r: IRepository, hasFailed: boolean): void => {
  if (hasFailed) {
    g.repoFailedCounter += 1
  } else {
    g.repoClonedCounter += 1
  }

  const n = r.isPrivate ? censor(r.owner.name, r.name) : r.fullName
  const c = fmt('cloned %s', _.padEnd(n, g.repoNamePad))
  const p = fmt('%s/%s completed', _.padStart(str(g.repoClonedCounter), g.counterPad), g.repoTotal)
  const f = g.repoFailedCounter > 0 ? fmt(', %s failed', g.repoFailedCounter.toString()) : ''

  g.spinner.ref.text = fmt('%s | %s', c, p.concat(f))
}

const concludeCloneSpinner = async (g: IGitCloneSpinner, s: CloneStatus[], e: CloneStatus[]): Promise<void> => {
  const destDirSize = (await ffs(DEST_DIR)) ?? 0
  const labelDownloaded = fmt('%s downloaded locally', fmtBytes(destDirSize))

  const cloned = fmt('%s/%s', _.padStart(str(len(s)), g.counterPad), g.repoTotal)
  const labelClonedColored = len(e) > 0 ? chalk.bold.red(cloned) : chalk.greenBright(cloned)

  if (len(e) === 0) {
    g.spinner.succeed(fmt('cloned %s (%s)', labelClonedColored, labelDownloaded))
  } else {
    g.spinner.fail(fmt('cloned %s (%s failed; %s)', labelClonedColored, len(e), labelDownloaded))
  }
}

const tickTimer = (wt: IWorkingTimer): void => {
  wt.elapsed += 50
  wt.spinner.ref.text = fmt('working... %s seconds elapsed', (wt.elapsed / 1000).toFixed(2))
}

/* -------------------------------------------------------------------------
                           GIT / GITHUB INTERACTIONS
   ------------------------------------------------------------------------- */

const cloneLocally = async (g: IGitCloneSpinner, token: string, user: string, r: IRepository): Promise<IRepository> => {
  const d = path.join(DEST_DIR, r.owner.name)

  try {
    const git = Git()
    const url = r.isPrivate ? fmt('https://%s:%s@github.com/%s/%s', user, token, r.owner.name, r.name) : r.url

    await git.clone(url, path.join(d, r.name))
    updateCloneSpinner(g, r, false)

    return r
  } catch (e) {
    log(e)
    updateCloneSpinner(g, r, true)

    throw e
  }
}

const zipCloned = async (): Promise<string> => {
  return await new Promise((resolve, reject) => {
    const dest = path.join(__dirname, 'gitexp-archive.zip')

    const archive = archiver('zip', { comment: 'generated by gitexp', zlib: { level: 8 } })
    const output = fs.createWriteStream(dest)

    archive.pipe(output)
    archive.directory(DEST_DIR, false)
    output.on('close', () => resolve(dest))
    archive.on('error', (err) => reject(err))

    archive
      .finalize()
      .then(() => resolve(dest))
      .catch((err) => reject(err))
  })
}

const createClonedZIPArchive = async (sb: SpinnyBuilder): Promise<void> => {
  const sp = sb('archive', 'creating ZIP archive')

  try {
    const archiveDest = await zipCloned()
    const destDirSize = (await ffs(DEST_DIR)) ?? 1
    const archive = await fs.promises.stat(archiveDest)
    const reduced = (100 - (archive.size * 100) / destDirSize).toFixed(2).concat('%')

    sp.succeed(fmt('ZIP archive created (%s, %s size reduction)', fmtBytes(archive.size), reduced))
  } catch (e) {
    sp.fail(chalk.bold.red(errMsg(e)))

    throw e
  }
}

const categorizeRepositories = (repos: IRepository[]): IGitHubStats => {
  const rank = (i: string[]): IOccurence[] => {
    const r = Object.fromEntries(uniq(i).map((l) => [l, 0]))
    i.forEach((l) => r[l]++)

    return Object.keys(r)
      .map((name) => ({ name, count: r[name] }))
      .sort((a, b) => b.count - a.count)
  }

  const langs: string[] = []
  const users: string[] = []
  const orgs: string[] = []

  const s: IGitHubStats = {
    repos: { pub: [], priv: [] },
    langs: [],
    users: [],
    orgs: []
  }

  for (const r of repos) {
    if (r.isPrivate) {
      s.repos.priv.push(r.fullName)
    } else {
      s.repos.pub.push(r.fullName)
    }

    if (r.owner.isOrg) {
      orgs.push(r.owner.name)
    } else {
      users.push(r.owner.name)
    }

    langs.push(r.lang)
  }

  s.users = rank(users)
  s.orgs = rank(orgs)
  s.langs = rank(langs)

  return s
}

const fetchAllRepositories = async (sb: SpinnyBuilder, client: Octokit): Promise<IUserRepositories> => {
  const sp = sb('fetchAllRepositories', 'fetching repositories')

  const r: IRepository[] = []
  const list = client.rest.repos.listForAuthenticatedUser

  for (let page = 1; ; page++) {
    const d = await list({ page, visibility: 'all', per_page: 100 })

    if (d.status !== 200) {
      throw new Error(fmt('[%s] Unable to fetch; got: \n%s', fetchAllRepositories.name, JSON.stringify(d)))
    }

    if (len(d.data) === 0) {
      break
    }

    r.push(
      ...d.data.map((repo) => ({
        name: repo.name,
        fullName: repo.full_name,
        url: repo.clone_url,
        isPrivate: repo.private,
        lang: (repo.language ?? 'n/a').toLowerCase(),
        owner: {
          name: _.first(repo.full_name.split('/')) ?? 'n/a',
          isOrg: repo.owner?.type.toLowerCase() === 'organization'
        }
      }))
    )
  }

  const s = categorizeRepositories(r)
  const m = fmt(
    '(%s; %s; %s; %s)',
    plural('public', len(s.repos.pub), true),
    plural('private', len(s.repos.priv), true),
    plural('organization', len(s.orgs), true),
    plural('user', len(s.users), true)
  )

  sp.succeed(fmt('found %s %s', plural('repository', len(r), true), (len(r), len(r) > 0 ? m : '')))
  return { repositories: r, stats: s }
}

const authenticate = async (sb: SpinnyBuilder): Promise<IGitHubAuthData> => {
  const sp = sb('authenticate', 'authenticating')

  try {
    const authToken = process.env.GITHUB_AUTH_TOKEN
    if (authToken === undefined) {
      throw new Error('GitHub token is undefined')
    }

    const client = new Octokit({ auth: process.env.GITHUB_AUTH_TOKEN })
    const { data } = await client.rest.users.getAuthenticated()

    const login = chalk.cyan(fmt('@%s', data.login))
    const name = data.name !== undefined ? fmt('(%s)', chalk.italic(data.name)) : ''
    sp.succeed(fmt('authenticated as %s %s', login, name))

    return {
      authToken,
      client,
      authUserData: { name: data.name ?? '', login: data.login }
    }
  } catch (e) {
    sp.fail(chalk.bold.red(errMsg(e)))

    throw e
  }
}

/* -------------------------------------------------------------------------
                             CLI & USER INTERACTION
   ------------------------------------------------------------------------- */

const setArgsFallback = (opts: OptionValues): ICloneFilters => ({
  visibility: opts.visibility ?? RepoVisibility.ALL,
  ownerType: opts.ownerType ?? RepoOwnerType.ALL,
  onlyFrom: opts.onlyFrom ?? null,
  languages: opts.languages ?? null
})

const showGithubSummary = (stats: IGitHubStats): void => {
  const h = (t: string): void => log(chalk.cyan(t))

  if (len(stats.langs) > 0) {
    h('\nprimary languages used by your projects, ordered by occurences:\n')
    log(tabulateOccurrences(stats.langs))
  }

  if (len(stats.users) > 0) {
    h('\nusers, ordered by the amount of owned projects:\n')
    log(tabulateOccurrences(stats.users))
  }

  if (len(stats.orgs) > 0) {
    h('\norganizations, ordered by the amount of owned projects:\n')
    log(tabulateOccurrences(stats.orgs))
  }
}

// @ts-expect-error
const getRunningOptionsInteractively = (): ICloneFilters => {}

const filterReposByUserInput = (repositories: IRepository[], f: ICloneFilters): IRepository[] =>
  repositories
    /* repository visibility filter; should only gets public? or private? or both? */
    .filter(
      (r) =>
        f.visibility === RepoVisibility.ALL ||
        (r.isPrivate && f.visibility === RepoVisibility.PRIVATE) ||
        (!r.isPrivate && f.visibility === RepoVisibility.PUBLIC)
    )

    /* repository main language filter; gets only if the main lang is X (python, js etc) */
    .filter((r) => f.languages === null || f.languages.includes(r.lang))

    /* repository owner filter; gets only if the owner is X */
    .filter((r) => f.onlyFrom === null || f.onlyFrom.includes(r.owner.name))

    /* repository owner type filter; should only gets repos from orgs? or users? or both? */
    .filter(
      (r) =>
        f.ownerType === RepoOwnerType.ALL ||
        (r.owner.isOrg && f.ownerType === RepoOwnerType.ORG) ||
        (!r.owner.isOrg && f.ownerType === RepoOwnerType.USER)
    )

/* -------------------------------------------------------------------------
                                   ENTRYPOINT
   ------------------------------------------------------------------------- */

const main = async (): Promise<void> => {
  const cliOptions = parseCommandLineArgs(process.argv)
  const showSummary = cliOptions.summary !== undefined
  const runInteractive = cliOptions.interactive !== undefined

  clear()
  const banner = len(figlets) > 0 ? _.sample(figlets) : ''
  log(chalk.gray(banner))

  const startTS = new Date()

  const suppressLoadingSpinners = showSummary || IS_RUNNING_ON_CI_ENV || isDef('IS_RUNNING_ON_DOCKER')
  const sb = spinnyBuilder(cliSpinner.point, suppressLoadingSpinners)

  const wt: IWorkingTimer = { spinner: sb('main', 'working...'), elapsed: 0 }
  const gewt = setInterval(tickTimer, 50, wt)

  /* ... */
  const { client, authToken, authUserData } = await authenticate(sb)
  const { repositories, stats } = await fetchAllRepositories(sb, client)

  if (showSummary) {
    showGithubSummary(stats)
    process.exit(0)
  }

  const reposF = filterReposByUserInput(
    repositories,
    runInteractive ? getRunningOptionsInteractively() : setArgsFallback(cliOptions)
  )

  const gcs: IGitCloneSpinner = {
    repoClonedCounter: 0,
    repoFailedCounter: 0,
    repoTotal: str(len(reposF)),
    counterPad: len(str(len(reposF))),
    repoNamePad: len(largestWord(reposF.map((r) => r.fullName))),
    spinner: sb('cloning', 'cloning repositories')
  }

  const repoCloneStatus: CloneStatus[] = []
  for (const chunk of _.chunk(reposF, 10)) {
    /* eslint-disable-next-line */
    const calls = chunk.map((repo) => cloneLocally(gcs, authToken, authUserData.login, repo))

    const res = await Promise.allSettled(calls)
    res.forEach((i) => repoCloneStatus.push(i))
  }

  const clonedSuccessfully = repoCloneStatus.filter((r) => r.status === 'fulfilled')
  const clonedWithErrors = _.xor(repoCloneStatus, clonedSuccessfully)

  await concludeCloneSpinner(gcs, clonedSuccessfully, clonedWithErrors)
  await createClonedZIPArchive(sb)

  clearInterval(gewt)
  wt.spinner.succeed(fmt('job finished in %s', getElapsedTimeFormatted(startTS)))
}

main().catch((e) => panic(e))
